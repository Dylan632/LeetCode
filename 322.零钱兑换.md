---
type: algorithm
tags:
  - 完全背包
category: 动态规划
difficulty: 🟡 Medium
leetcode: 322
created: 2026-02-28 00:03
obsidian-note-status:
  - colorful:completed
---

## 题目
![[322.png]]
**提示：**

- `1 <= coins.length <= 12`
- `1 <= coins[i] <= 2^31 - 1`
- `0 <= amount <= 10^4`

## 思路（必填）

### 算法选择

完全背包 DP。硬币可重复使用 → 完全背包；求最少数量 → 最小值 DP。

### 实现步骤

1. 定义 `dp[j] = 凑成金额 j 的最少硬币数`
2. 初始化 `dp[0] = 0`，其余设为不可达标记 `amount + 1`
3. 对每种硬币，正序遍历金额做状态转移：`dp[j] = min(dp[j], dp[j-coin] + 1)`
4. 检查 `dp[amount]` 是否仍为不可达，是则返回 `-1`

## 关键点
>[!Tip] 正序遍历（区别于 0-1 背包的逆序）保证同一硬币可被多次选取。

## 代码

```java
class Solution {  
    public int coinChange(int[] coins, int amount) {  
        int[] dp = new int[amount + 1];  
        // 初始化为 amount + 1
        final int UNREACHABLE = amount + 1;
        Arrays.fill(dp, UNREACHABLE);  
        // 当金额为0时需要的硬币数目为0  
        dp[0] = 0;  
        for (int coin : coins) {  
            // 正序遍历金额：完全背包每个硬币可以选择多次  
            for (int j = coin; j <= amount; j++) {  
                // 选择硬币数目最小的情况  
                dp[j] = Math.min(dp[j], dp[j - coin] + 1);  
            }  
        }  
        return dp[amount] == UNREACHABLE ? -1 : dp[amount];  
    }  
}
```

## 过程详解

用 `coins = [1, 2, 5], amount = 5` 举例，图解完整 DP 过程。
### 初始状态
```text
金额：   0    1    2    3    4    5
dp[] ：[ 0 ][ 6 ][ 6 ][ 6 ][ 6 ][ 6 ]
         ↑    ↑
       基础情况  amount+1 = 6（代表不可达）
```
### 第一轮：处理 coin = 1
从 j = 1 正序遍历到 j = 5： 
```text
j=1: dp[1] = min(6, 0+1) = 1   ← 用 1 枚 1 元
j=2: dp[2] = min(6, 1+1) = 2   ← 用 2 枚 1 元
j=3: dp[3] = min(6, 2+1) = 3   ← 用 3 枚 1 元
j=4: dp[4] = min(6, 3+1) = 4   ← 用 4 枚 1 元
j=5: dp[5] = min(6, 4+1) = 5   ← 用 5 枚 1 元

金额：   0    1    2    3    4    5
dp[] ：[ 0 ][ 1 ][ 2 ][ 3 ][ 4 ][ 5 ]
              全是 1 元硬币
```
### 第二轮：处理 coin = 2
从 j = 2 正序遍历到 j = 5：
```text
j=2: dp[2] = min(2, 0+1) = 1 ✨  之前 1+1=2 枚 → 现在 2=1 枚
j=3: dp[3] = min(3, 1+1) = 2 ✨  2+1=2 枚，比 1+1+1=3 枚更少
j=4: dp[4] = min(4, 1+1) = 2 ✨  2+2=2 枚（正序遍历让 dp[2] 已更新为 1）
j=5: dp[5] = min(5, 2+1) = 3 ✨  2+2+1=3 枚

金额：   0    1    2    3    4    5
dp[] ：[ 0 ][ 1 ][ 1 ][ 2 ][ 2 ][ 3 ]
                   ↑         ↑
                 1 枚 2 元  2 枚 2 元（正序遍历的威力）
```

> [!important] 正序遍历的关键
> `j=4` 时：`dp[4] = dp[4-2] + 1 = dp[2] + 1`，而 `dp[2]` 在本轮已被更新为 1（1 枚 2 元），所以 `dp[4] = 1 + 1 = 2`（2 枚 2 元）。
> 如果是**逆序遍历**（0-1 背包），`dp[2]` 还是旧值 2，`dp[4] = 2+1 = 3`，就不能重复用 2 元了。
### 第三轮：处理 coin = 5
从 j = 5 遍历到 j = 5（只有一个位置）：
```text
j=5: dp[5] = min(3, 0+1) = 1 ✨  直接用 1 枚 5 元，比 2+2+1=3 枚更优

金额：   0    1    2    3    4    5
dp[] ：[ 0 ][ 1 ][ 1 ][ 2 ][ 2 ][ 1 ]
                                    ↑
                                 1 枚 5 元 🎉
```
### 全过程汇总

```text
           金额→    0    1    2    3    4    5
         ┌───────┬────┬────┬────┬────┬────┬────┐
  初始化  │  dp   │  0 │  6 │  6 │  6 │  6 │  6 │
         ├───────┼────┼────┼────┼────┼────┼────┤
  coin=1 │  dp   │  0 │  1 │  2 │  3 │  4 │  5 │
         ├───────┼────┼────┼────┼────┼────┼────┤
  coin=2 │  dp   │  0 │  1 │ *1 │ *2 │ *2 │ *3 │
         ├───────┼────┼────┼────┼────┼────┼────┤
  coin=5 │  dp   │  0 │  1 │  1 │  2 │  2 │ *1 │ 最后一行是凑成金额x所用的硬币数
         └───────┴────┴────┴────┴────┴────┴────┘
  * 表示本轮被更新的位置       dp[5]=1 ≤ 5 → 返回 1
```
### 最终方案还原
`dp[5] = 1` ← 由 coin = 5 得到：`dp[5] = dp[5-5] + 1 = dp[0] + 1`，即选 1 枚 5 元硬币凑成 5 元。
> [!note] 核心要点
> 每一轮加入新硬币后，DP 表中已有的值只会**变小或不变**，永远不会变大——因为 `Math.min` 保证了只在更优时才更新。三轮遍历结束后，`dp[amount]` 就是全局最优解。

## 知识点

### 用 `amount + 1` 替代 `Integer.MAX_VALUE`优化

**好处一：代码更简洁。** `Arrays.fill` 一行搞定，不需要手写循环。

**好处二：彻底消除溢出问题。** 这是关键——

- 用 `Integer.MAX_VALUE` 时，`dp[j - coin] + 1` 会变成负数（整数溢出），所以必须加一个 `if` 判断来防护
- 用 `amount + 1` 时，`dp[j - coin] + 1` 最大也就是 `amount + 2`，绝对不会溢出，所以内层循环可以直接做 `Math.min`，不需要任何 `if`

**为什么 `amount + 1` 可以当”不可达”标记？**

假设所有硬币面值最小为 1，凑成 `amount` 最多需要 `amount` 枚硬币。所以任何合法答案都 `<= amount`。`amount + 1` 就代表“不可能达到”，逻辑上等价于无穷大，但数值上安全。

## 复杂度

- Time: O(n × amount)
- Space: O(amount)

n 为硬币种类数，外层遍历硬币，内层遍历金额；dp 数组长度 amount + 1。

## 相似题目

- [[70.爬楼梯]]
- [[279.完全平方数]]

