---
type: algorithm
tags:
  - 递归
category: 二叉树
difficulty: 🟢 Easy
leetcode: 104
created: 2026-02-11 15:25
obsidian-note-status:
  - colorful:completed
---

## 题目
![[104.png]]

## 思路（必填）
### 算法选择
后序遍历（左→右→根）。需要先知道左右子树的深度，才能计算当前节点的深度，这天然符合后序遍历“先处理子节点、再处理当前节点”的顺序。
### 实现步骤
1. 基线条件：空节点深度为 0
2. 递归求左子树深度
3. 递归求右子树深度
4. 当前节点深度 = max(左, 右) + 1

## 详细讲解

### 题目本质
给定一棵二叉树，求从根节点到最远叶子节点的路径上的节点数。
```
    3          深度 1
   / \
  9  20        深度 2
    /  \
   15   7      深度 3
```
> 答案：3
### 逐行解析
```java
public int maxDepth(TreeNode root) {
```
方法签名：输入一棵树的根节点，返回一个 int 表示最大深度。
```java
if (root == null) {
    return 0;
}
```
递归终止条件（base case）。当节点为空时，说明已经越过了叶子节点，深度为 0。这是整个递归能够“收住”的关键。
举例：一个叶子节点 7，它的左右孩子都是 null，所以：
- `maxDepth(7.left)` → null → 返回 0
- `maxDepth(7.right)` → null → 返回 0
- `max(0, 0) + 1 = 1` ← 叶子节点深度正确为 1
```java
int leftDepth = maxDepth(root.left);
```
递归求左子树的最大深度。这一步把“求整棵树的深度”这个大问题，缩小为“求左子树的深度”这个子问题。此时我们不需要关心左子树内部怎么算的，只需要相信它能返回正确结果（递归的信任）。
```java
int rightDepth = maxDepth(root.right);
```
递归求右子树的最大深度。同理，把问题缩小为右子树的子问题。
```java
return Math.max(leftDepth, rightDepth) + 1;
```
合并结果。当前节点的最大深度 = 左右子树中较大的那个 + 1（加上当前节点自身这一层）。
### 为什么是后序遍历
二叉树遍历有三种顺序：

| 遍历方式 | 顺序     | 特点                 |
| -------- | -------- | -------------------- |
| 前序     | 根→左→右 | 自顶向下，先处理自己 |
| 中序     | 左→根→右 | 常用于 BST           |
| 后序     | 左→右→根 | 自底向上，先处理孩子 |
本题代码的执行顺序：
1. 先递归处理左子树 → `leftDepth`
2. 再递归处理右子树 → `rightDepth`
3. 最后处理当前节点 → `Math.max() + 1`
这就是 **左→右→根**，即后序遍历。因为我们必须先知道孩子的深度，才能算出自己的深度。
### 递归执行过程（完整模拟）
以这棵树为例：
```
    3
   / \
  9  20
    /  \
   15   7
```

```
maxDepth(3)
├── leftDepth = maxDepth(9)
│   ├── maxDepth(null) → 0
│   ├── maxDepth(null) → 0
│   └── max(0,0)+1 = 1  ✅ 返回 1
├── rightDepth = maxDepth(20)
│   ├── leftDepth = maxDepth(15)
│   │   ├── maxDepth(null) → 0
│   │   ├── maxDepth(null) → 0
│   │   └── max(0,0)+1 = 1  ✅ 返回 1
│   ├── rightDepth = maxDepth(7)
│   │   ├── maxDepth(null) → 0
│   │   ├── maxDepth(null) → 0
│   │   └── max(0,0)+1 = 1  ✅ 返回 1
│   └── max(1,1)+1 = 2  ✅ 返回 2
└── max(1,2)+1 = 3  ✅ 返回 3
```
> 最终结果：**3**
### 递归三要素总结
写任何递归都需要想清楚这三点：

| 要素          | 本题的回答                                                  |
| ------------- | ----------------------------------------------------------- |
| 1. 函数的含义 | `maxDepth(node)` 返回以 node 为根的子树的最大深度           |
| 2. 终止条件   | `node == null` 时返回 0                                     |
| 3. 递推关系   | `maxDepth(node) = max(maxDepth(left), maxDepth(right)) + 1` |
### 深度 vs 高度
这两个概念容易混淆：
- **深度**：从根节点到该节点的边数（或节点数，看定义）—— 自顶向下
- **高度**：从该节点到最远叶子节点的边数 —— 自底向上
本题求的是“<font color="#ff0000">最大深度</font>”，但实现上其实是在求根节点的高度。高度是自底向上计算的，所以用后序遍历。两者在根节点上数值相等，这就是为什么后序遍历能求出最大深度。
## 关键点
>[!Tip] maxDepth(3)
├── leftDepth = maxDepth(9)
│   ├── maxDepth(null) → 0
│   ├── maxDepth(null) → 0
│   └── max(0,0)+1 = 1  ✅ 返回 1
├── rightDepth = maxDepth(20)
│   ├── leftDepth = maxDepth(15)
│   │   ├── maxDepth(null) → 0
│   │   ├── maxDepth(null) → 0
│   │   └── max(0,0)+1 = 1  ✅ 返回 1
│   ├── rightDepth = maxDepth(7)
│   │   ├── maxDepth(null) → 0
│   │   ├── maxDepth(null) → 0
│   │   └── max(0,0)+1 = 1  ✅ 返回 1
│   └── max(1,1)+1 = 2  ✅ 返回 2
└── max(1,2)+1 = 3  ✅ 返回 3

## 代码

```java
class Solution {  
    public int maxDepth(TreeNode root) {  
        if (root == null) {  
            return 0;  
        }  
        //左右中，后序  
        int leftDepth = maxDepth(root.left);  
        int rightDepth = maxDepth(root.right);  
        //左右孩子的最大深度+根节点本身（1）就是二叉树的最大深度  
        return Math.max(leftDepth, rightDepth) + 1;  
    }  
}
```

## 知识点
- **前序 (Pre-order)**：先办我自己的事，再去找孩子。（中左右）
- **后序 (Post-order)**：先等孩子们把结果给我，我汇总之后再办自己的事。（左右中）
求深度必须是**后序**。因为如果没有孩子的高度数据，你根本算不出自己的高度！这就好比盖楼，必须先盖好一楼二楼（子节点），才能说这楼盖到了三楼（根节点）。

## 复杂度

- Time: O(n)，其中`n`为二叉树节点的个数。每个节点在递归中只被遍历一次。
- Space: O(height)，其中`height`表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。

## 相似题目

- [[ ]]

