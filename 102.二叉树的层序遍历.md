---
type: algorithm
tags:
category: 二叉树
difficulty: 🟡 Medium
leetcode: 102
created: 2026-02-11 15:25
obsidian-note-status:
  - colorful:archived
---

## 题目
![[102.png]]

## 思路（必填）
![[102_1.png]]
1. 根节点入队。
2. 进入外层 `while` 循环——只要队列非空，说明还有层没处理完。
3. 记录当前队列大小 `levelSize`，即当前层的节点数。
4. 内层 `for` 循环处理 `levelSize` 个节点：出队、记录值、将左右孩子入队。
5. 内层循环结束，当前层处理完毕，将该层结果加入最终列表。
### 算法选择：
BFS（广度优先搜索）天然按层扩展，配合队列实现逐层处理。关键在于如何区分"当前层"和"下一层"——在每轮外层循环开始时，队列中恰好存放着当前层的所有节点，记录此时队列的大小 `levelSize`，然后只处理这 `levelSize` 个节点，就完成了一层的遍历。

## 💭 代码思路（详细讲解）

你说不太懂，我用一个具体例子从头到尾走一遍。假设我们有这棵树：
```
        3
       / \
      9   20
         /  \
        15   7
```
目标输出：`[[3], [9, 20], [15, 7]]`——按层分组。
**核心思想：用队列模拟"排队"。**
想象一个售票窗口，树的节点是来买票的人。规则是：
- 每个人买完票后，把自己的孩子叫来排队
- 我们需要记录"第几批人一起在排队"
---
### 逐行执行过程：
1. 创建空的结果列表 `result = []`，创建空队列 `queue = []`
2. 根节点 3 入队 → `queue = [3]`
3. 进入 while 循环（队列非空）
### 第一轮 while（处理第 1 层）：
`queue = [3]`，`levelSize = 1`（当前层有 1 个节点）
for 循环执行 1 次：
- i=0：取出 3，`level = [3]`，把 3 的左孩子 9 和右孩子 20 入队
`queue = [9, 20]`
`result = [[3]]`

> [!important] 为什么要提前记录 `levelSize = queue.size()`？
> 因为 for 循环中我们会往队列里添加下一层的节点。如果不提前记住"当前层有几个"，就分不清哪些是当前层、哪些是下一层。
### 第二轮 while（处理第 2 层）：
`queue = [9, 20]`，`levelSize = 2`（当前层有 2 个节点）
for 循环执行 2 次：
- i=0：取出 9，`level = [9]`，9 没有孩子，不入队
- i=1：取出 20，`level = [9, 20]`，把 20 的左孩子 15 和右孩子 7 入队
`queue = [15, 7]`
`result = [[3], [9, 20]]`
### 第三轮 while（处理第 3 层）：
`queue = [15, 7]`，`levelSize = 2`
for 循环执行 2 次：
- i=0：取出 15，`level = [15]`，无孩子
- i=1：取出 7，`level = [15, 7]`，无孩子
`queue = []`（空了）
`result = [[3], [9, 20], [15, 7]]`

队列为空，while 循环结束，返回 result。
整个过程的核心就两件事：
1. 出队一个节点 → 记录它的值
2. 入队它的孩子 → 留给下一层处理
`levelSize` 就像一个"闸门"，确保每轮只处理当前层的节点。

## 关键点
>[!Tip] levelSize = queue.size() 必须在内层循环之前记录，因为循环过程中会往队列里添加下一层的节点，如果不提前记录，就无法区分当前层和下一层的边界。

## 代码

```java
class Solution {  
    public List<List<Integer>> levelOrder(TreeNode root) {  
        List<List<Integer>> result = new ArrayList<>();  
        if (root == null) {  
            return result;  
        }  
  
        Queue<TreeNode> queue = new LinkedList<>();  
        // 根节点入队（第一个人来排队了）  
        // queue.offer() 意思就是“请进队”。  
        // 此时队列里只有：[root]  
        queue.offer(root);  
  
        while (!queue.isEmpty()) {  
            List<Integer> level = new ArrayList<>();  
            // 在内循环for之前，记录当前队列的长度
            int levelSize = queue.size();  
  
            for (int i = 0; i < levelSize; i++) {  
                // queue.poll()：取出并从队列中删除第一个节点。  
                TreeNode node = queue.poll();  
                level.add(node.val);  
                if (node.left != null) {  
                    queue.offer(node.left);  
                }  
                if (node.right != null) {  
                    queue.offer(node.right);  
                }  
            }  
            result.add(level);  
        }  
        return result;  
    }  
}
```

## 改错
### 局部变量不能加 public
```java
// ❌ 你写的：
public List<List<Integer>> result = new ArrayList<>();
// ✅ 应该写：
List<List<Integer>> result = new ArrayList<>();
```
为什么？ Java 中 `public、private、protected` 这些叫做访问修饰符，它们只能用在两个地方：
- 类的字段（写在方法外面的变量）
- 类的方法
而 `result` 现在写在 `levelOrder()` 方法里面，它是一个局部变量。局部变量的作用范围只在这个方法内部，方法结束就消失了，所以不存在"谁能访问它"的问题，Java 语法不允许给它加访问修饰符。
简单记：方法里面声明的变量，前面不加任何修饰符，直接写类型就行。

## 知识点

### 1. result 的数据类型
```java
List<List<Integer>> result = new ArrayList<>();
```
- `ArrayList<>`：动态数组，是`List`接口的一种具体实现，底层用数组存数据，支持自动扩容。
- 数据类型：`List<List<Integer>>`
- 含义：
  - `List<...>`：一个“列表/动态数组”。
  - 里面放的是 `List<Integer>`，也就是“一层的所有节点值”。
- 所以：`result` 是一个“列表的列表”：
  - `result.get(0)`：第 0 层（根节点这一层）的所有值列表。
  - `result.get(1)`：第 1 层的所有值列表。
  - ...
- 结构大概是这样：
```
[
  [第0层的所有值],
  [第1层的所有值],
  [第2层的所有值],
  ...
]
```

### 2. level 的数据类型
```java
List<Integer> level = new ArrayList<>();
```
- 数据类型：`List<Integer>`
- 含义：
  - `level` 表示“当前这一层的所有节点的值”的列表。
  - 在 `while (!queue.isEmpty())` 的每一轮循环里：
    - 新建一个 `level`，只存当前这一层的节点的值。
    - 一层处理完之后，执行 `result.add(level);`，把这一层的结果存进总结果 `result` 里。
可以理解为：
- `result` 是“总成绩单（很多行）”
- `level` 是“这一行的成绩”

### 3. node 的数据类型
```java
TreeNode node = queue.poll();
```
- 数据类型：`TreeNode`
- 含义：`TreeNode` 是题目定义的“二叉树节点”类：
```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
}
```
- 所以 `node` 是“当前正在处理的这个树节点”。
- 你可以通过：
  - `node.val` 访问当前节点的值（整数）
  - `node.left` 访问它的左孩子
  - `node.right` 访问它的右孩子
### 4. node.val
- `node`：指向当前二叉树结点的变量（通常类型是 `TreeNode`）。
- `val`：这个结点里存储的数值字段，在 `TreeNode` 类里一般定义为 `int val;`。
所以 `level.add(node.val);` 就是：把当前这个结点中存的数值（`val`）加入到当前这一层的列表 `level` 里。

## 复杂度
 
 每个节点入队出队各一次；队列最多存一层节点（最坏 n/2）
- Time: O(n)
- Space: O(n)

## 相似题目

- [[104.二叉树的最大深度]]
