---
type: algorithm
tags: 
category: 
difficulty: 
leetcode: 226
created: "2026-02-11 14:55"
---

## 题目
![[226.png]]

## 思路（必填）

1. 
2. 
3. 

## 关键点
>[!Tip]

## 代码

```java
class Solution {  
    public TreeNode invertTree(TreeNode root) {  
        if (root == null) {  
            return null;  
        }  
        //后序遍历，左右中  
        invertTree(root.left);  
        invertTree(root.right);  
        swapChildren(root);  
        return root;  
    }  
    private void swapChildren(TreeNode root) {  
        TreeNode temp = root.left;  
        root.left = root.right;  
        root.right = temp;  
    }  
}
```

## 知识点
`root` 的真实身份是：“当前正在处理的这个节点”。
完整的递归过程：
### 0. 你的例子数据

- **输入树**：
- ```
           4
         /   \
        2     7
       / \   / \
      1   3 6   9
    ```
- **目标**：把它翻转过来。
- **你的代码逻辑**（后序遍历）：
    1. `invertTree(root.left)` （先搞定左边）
    2. `invertTree(root.right)` （再搞定右边）
    3. `swapChildren(root)` （最后交换自己的左右手）
---

### 第一阶段：顺藤摸瓜（递）—— 一路向下，老板派活
程序开始运行，`root` 是 **4**。
1. **节点 4 (大老板)**：
    - 执行 `invertTree(4.left)`。也就是呼叫 **节点 2**。
    - **4 号暂停**，等待 2 号的结果。
2. **节点 2 (二老板)**：
    - 执行 `invertTree(2.left)`。也就是呼叫 **节点 1**。
    - **2 号暂停**，等待 1 号的结果。
3. **节点 1 (小兵)**：
    - 执行 `invertTree(1.left)` -> 也就是呼叫 `null` -> 返回 `null`。
    - 执行 `invertTree(1.right)` -> 也就是呼叫 `null` -> 返回 `null`。
    - **1 号暂停结束，开始干活**：
        - 执行 `swapChildren(1)`。把左 `null` 和右 `null` 换一下（无事发生）。
    - **1 号交差**：`return 1`。

---

### 第二阶段：触底反弹（归）—— 还是在左半边
4. **回到 节点 2 (二老板)**：
    - 左边的任务（找 1）结束了。
    - 现在执行 `invertTree(2.right)`。也就是呼叫 **节点 3**。
    - **2 号再次暂停**，等待 3 号的结果。
5. **节点 3 (小兵)**：
    - （同节点 1 一样，左右都是 null，换了个寂寞）。
    - **3 号交差**：`return 3`。
6. **回到 节点 2 (二老板)**：
    - 左边（1）搞好了，右边（3）也搞好了。
    - **2 号终于可以干活了！**
    - 执行 `swapChildren(2)`：
        - 原本：左手拿 1，右手拿 3。
        - **交换！** 现在左手拿 3，右手拿 1。
        - 现在的 2 变成了：
            ```
                2
               / \
              3   1
            ```
    - **2 号交差**：带着这个翻转好的“小三角” `[2, 3, 1]` 返回给 4 号。

---
### 第三阶段：另一条线（右半边）—— 同样的剧本
7. **回到 节点 4 (大老板)**：
    - 左边的任务终于彻底结束了！
    - 现在执行 `invertTree(4.right)`。也就是呼叫 **节点 7**。
    - **4 号再次暂停**，等待 7 号的结果。
8. **节点 7 (二老板)**：
    - 按照同样的逻辑，它会先派 **6** 去翻转，再派 **9** 去翻转。
    - 6 和 9 都是叶子节点，自己翻转完（无事发生）就回来了。
    - **7 号开始干活**：
        - 执行 `swapChildren(7)`。
        - 原本：左手拿 6，右手拿 9。
        - **交换！** 现在左手拿 9，右手拿 6。
        - 现在的 7 变成了：
            
            ```
                7
               / \
              9   6
            ```
    - **7 号交差**：带着翻转好的 `[7, 9, 6]` 返回给 4 号。
---

### 第四阶段：大结局（根节点操作）
9. **回到 节点 4 (大老板)**：
    - 左边任务 `invertTree(2)` 返回了：**`[2, 3, 1]`**。
    - 右边任务 `invertTree(7)` 返回了：**`[7, 9, 6]`**。
    - **4 号终于可以干活了！**
    - 执行 `swapChildren(4)`：
        - 原本：左指针指向 `Node(2)`，右指针指向 `Node(7)`。
        - **交换！**
        - 左指针改为指向 `Node(7)`。
        - 右指针改为指向 `Node(2)`。

### 最终结果展示
此时，整棵树的结构变成了：
```
       4
     /   \
    7     2
   / \   / \
  9   6 3   1
```


### 总结代码逻辑
在这个例子里：
1. **节点 1, 3, 6, 9**：只是跑了个龙套，因为没孩子，交换了个寂寞。
2. **节点 2**：把孩子 1 和 3 换了位置，变成了 `3-2-1`。
3. **节点 7**：把孩子 6 和 9 换了位置，变成了 `9-7-6`。
4. **节点 4**：最后出场，把整个左膀（2的那一坨）和右臂（7的那一坨）互换。

这就解释了为什么必须用后序遍历（或者把交换放在递归之后）：

“先把局部的小零件装反（2 和 7 的内部），最后再把这两个大零件的位置对调（4 的左右）。”

## 复杂度

- Time: O()
- Space: O()

---

## 相似题目

- [[ ]]

