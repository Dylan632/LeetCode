---
type: algorithm
tags:
  - 哈希表、双指针
category: 链表
difficulty: 🟡 Medium
leetcode: 142
created: 2026-02-10 15:43
---

## 题目
![[142.png]]

## 思路（必填）
1. 快慢指针同步出发，slow 每次一步，fast 每次两步。
2. 若 fast 到 null，说明无环，返回 null。
3. 若 slow == fast，说明有环。
4. 将一指针放回 head，另一指针留在相遇点，同速一步步前进。
5. 再次相遇处即入环点。  

## 关键点
利用距离关系证明“头到入口距离 == 相遇点到入口距离（模环长）”。

## 代码

```java
public class Solution {  
    public ListNode detectCycle(ListNode head) {  
        ListNode slow = head;  
        ListNode fast = head;  
        while (fast != null && fast.next != null) {  
            slow = slow.next;  
            fast = fast.next.next;  
            //有环  
            if (slow == fast) {  
                ListNode index1 = fast;  
                ListNode index2 = head;  
                while (index1 != index2) {  
                    index1 = index1.next;  
                    index2 = index2.next;  
                }  
                return index1;  
            }  
        }  
        return null;  
    }  
}
```

## 答案代码
> [!TIP]  

```java

```

## 知识点
![[142_1.png]]假设从头结点到环形入口节点的节点数为`x`。环形入口节点到fast指针与slow指针相遇节点节点数为`y`。从相遇节点再到环形入口节点节点数为`z`。
那么相遇时：slow指针走过的节点数为:`x + y`，fast指针走过的节点数：`x + y + n (y + z)`，n为fast指针在环内走了n圈才遇到slow指针，（y+z）为一圈内节点的个数A。
因为fast指针是一步走两个节点，slow指针一步走一个节点，所以fast指针走过的节点数=slow指针走过的节点数 * 2：
`(x + y) * 2 = x + y + n (y + z)`
两边消掉一个（x+y）: `x + y = n (y + z)`
因为要找环形的入口，那么要求的是x，因为x表示头结点到环形入口节点的的距离。
所以要求x，将x单独放在左面：`x = n (y + z) - y`,
再从n(y+z)中提出一个（y+z）来，整理公式之后为如下公式：`x = (n - 1) (y + z) + z`注意这里n一定是大于等于1的，因为fast指针至少要多走一圈才能相遇slow指针。
这个公式说明什么呢？
先拿n为1的情况来举例，意味着fast指针在环形里转了一圈之后，就遇到了slow指针了。
当n为1的时候，公式就化解为`x = z`，
这就意味着，**从头结点出发一个指针，从相遇节点也出发一个指针，这两个指针每次只走一个节点，那么当这两个指针相遇的时候就是环形入口的节点**。
也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2。
让index1和index2同时移动，每次移动一个节点，那么他们相遇的地方就是环形入口的节点。

## 复杂度

- Time: O()
- Space: O()

---

## 相似题目

- [[ ]]

