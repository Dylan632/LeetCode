---
type: algorithm
tags:
  - 哈希表、双指针
category: 链表
difficulty: 🟡 Medium
leetcode: 142
created: 2026-02-10 15:43
---

## 题目
![[142.png]]

## 思路（必填）
1. 快慢指针同步出发，slow 每次一步，fast 每次两步。
2. 若 fast 到 null，说明无环，返回 null。
3. 若 slow == fast，说明有环。
4. 将一指针放回 head，另一指针留在相遇点，同速一步步前进。
5. 再次相遇处即入环点。

## 关键点
利用距离关系证明"头到入口距离 == 相遇点到入口距离（模环长）"。

## 代码

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            //有环
            if (slow == fast) {
                ListNode index1 = fast;
                ListNode index2 = head;
                while (index1 != index2) {
                    index1 = index1.next;
                    index2 = index2.next;
                }
                return index1;
            }
        }
        return null;
    }
}
```

## 知识点
![[142_1.png]]

假设从头结点到环形入口节点的节点数为 `x`。环形入口节点到 fast 指针与 slow 指针相遇节点节点数为 `y`。从相遇节点再到环形入口节点节点数为 `z`。

那么相遇时：slow 指针走过的节点数为：`x + y`，fast 指针走过的节点数：`x + y + n (y + z)`，n 为 fast 指针在环内走了 n 圈才遇到 slow 指针，（y+z）为一圈内节点的个数。

因为 fast 指针是一步走两个节点，slow 指针一步走一个节点，所以 fast 指针走过的节点数 = slow 指针走过的节点数 * 2：

`(x + y) * 2 = x + y + n (y + z)`

两边消掉一个（x+y）：`x + y = n (y + z)`

因为要找环形的入口，那么要求的是 x，因为 x 表示头结点到环形入口节点的距离。所以要求 x，将 x 单独放在左面：`x = n (y + z) - y`，再从 n(y+z) 中提出一个（y+z）来，整理公式之后为如下公式：

`x = (n - 1) (y + z) + z`

注意这里 n 一定是大于等于 1 的，因为 fast 指针至少要多走一圈才能相遇 slow 指针。

先拿 n 为 1 的情况来举例，意味着 fast 指针在环形里转了一圈之后，就遇到了 slow 指针了。当 n 为 1 的时候，公式就化解为 `x = z`，这就意味着，**从头结点出发一个指针，从相遇节点也出发一个指针，这两个指针每次只走一个节点，那么当这两个指针相遇的时候就是环形入口的节点**。

也就是在相遇节点处，定义一个指针 index1，在头结点处定一个指针 index2。让 index1 和 index2 同时移动，每次移动一个节点，那么他们相遇的地方就是环形入口的节点。

## 复杂度

- Time: O()
- Space: O()

## 相似题目

- [[ ]]

