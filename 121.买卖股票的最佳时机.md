---
type: algorithm
tags:
  - 贪心
category: 动态规划
difficulty: 🟢 Easy
leetcode: 121
created: 2026-02-24 23:41
obsidian-note-status:
  - colorful:completed
---

## 题目

![[121.png]]

**提示：**

- $1 \leq \text{prices.length} \leq 10^5$
- $0 \leq \text{prices}[i] \leq 10^4$

## 思路（必填）

先考虑最简单的「暴力遍历」，即枚举出所有情况，并从中选择最大利润。设数组 prices 的长度为 n，由于只能先买入后卖出，因此第 1 天买可在未来 n−1 天卖出，第 2 天买可在未来 n−2 天卖出……以此类推，共有 $(n-1)+(n-2)+\cdots+0 = \frac{n(n-1)}{2}$ 种情况，时间复杂度为 $O(N^2)$。考虑到题目给定的长度范围 $1 \leq \text{prices.length} \leq 10^5$，需要思考更优解法。

然而，暴力法会产生许多冗余计算。例如，若第 1 天价格低于第 2 天价格，即第 1 天成本更低，那么我们一定不会选择在第 2 天买入。进一步的，若在前 i 天选择买入，若想达到最高利润，则一定选择价格最低的交易日买入。考虑根据此贪心思想，遍历价格列表 prices 并执行两步：

> 由于初始值 $i=0$，为了序号对应，本文设从第 0 天开始。

1. 更新前 i 天的最低价格，即最低买入成本 cost；
2. 更新前 i 天的最高利润 profit，即选择「前 $i-1$ 天最高利润 profit」和「第 $i$ 天卖出的最高利润 price - cost」中的最大值；

![[121_1.gif]]

### 算法选择

贪心法。核心洞察——最大利润 = 某天价格 - 该天之前的历史最低价。因此只需一次遍历，同时维护“历史最低价”和“最大利润”。

### 实现步骤

1. 用 `prices[0]` 初始化 `minPrice`，`maxProfit` 初始化为 0
2. 遍历每个价格：
   - 更新 `minPrice`：若当前价格更低则更新
   - 更新 `maxProfit`：当前价格减去历史最低价，与已有最大利润取较大值
3. 返回 `maxProfit`

## 关键点

> [!tip] 先更新 minPrice 再计算利润，当 price 恰好是新的最低价时 price - minPrice = 0，不会产生“同一天买卖”的错误利润，天然保证了“先买后卖”的时序约束。

## 代码

```java
class Solution {
    public int maxProfit(int[] prices) {
        int minPrice = prices[0];
        int maxProfit = 0;
        for (int price : prices) {
            minPrice = Math.min(minPrice, price);
            maxProfit = Math.max(maxProfit, price - minPrice);
        }
        return maxProfit;
    }
}
```
将cost用minPrice代替，将profit用maxProfit来代替。
## 知识点



## 复杂度

- **Time**：$O(N)$，其中 $N$ 为数组 prices 长度，遍历 prices 使用线性时间。
- **Space**：$O(1)$，变量 cost、profit 使用 $O(1)$ 空间。

## 相似题目

- [[42.接雨水]]
