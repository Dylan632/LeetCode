---
type: algorithm
tags:
category: 哈希
difficulty: 🟡 Medium
leetcode: 49
created: 2026-02-15 17:29
obsidian-note-status:
  - colorful:archived
---

## 题目
![[49.png]]

## 思路（必填）

1. 遍历每个字符串，将其字符排序得到标准化 `key`，使用哈希表的 `key` 存储排序后的字符串，每个 `key` 对应一个字母异位词的列表。
2. 以该 `key` 在哈希表中查找或创建对应列表。
3. 将原字符串加入列表。
4. 遍历结束后，哈希表的所有 `value` 即为分组结果。

## 关键点
>[!Tip] 如何定义“异位词的等价标识”——排序是最直观的方式，字符频次计数是更高效的方式。
>- **Key (`String`)**：存放排序后的“指纹”（例如 `"aet"`）。  
>- **Value (`List<String>`)**: 存放所有归为此类的原始单词（例如 `["eat", "tea", "ate"]`）。

## 代码

```java
class Solution {  
    public List<List<String>> groupAnagrams(String[] strs) {  
        // 创建哈希表：key 是排序后的字符串，value 是属于同一组的原始字符串列表  
        Map<String, List<String>> map = new HashMap<>(); 
        for (String str : strs) {  
            // 把str排序，作为哈希表的key  
            char[] array = str.toCharArray(); // "eat" → ['e','a','t']  
            Arrays.sort(array);       // ['e','a','t'] → ['a','e','t']  
            String key = new String(array);   // ['a','e','t'] → "aet"  
            // 到这里："eat"、"tea"、"ate" 排序后都变成 "aet"            
            // 所以它们会对应 map 里的同一个 key  
            // computeIfAbsent一行搞定：
            // 1. 如果 key 不存在 → 执行 lambda 创建新 ArrayList，自动放入 map，返回这个新list  
            // 2.如果key已存在→直接返回已有的list（lambda不执行，不会白创建对象）  
            // 3. 拿到 list 后直接 .add(str)            
            map.computeIfAbsent(key, k -> new ArrayList<>()).add(str);  
            // 上面这个 k 是 lambda 的参数（就是 key），这里没用到它  
        }  
        return new ArrayList<List<String>>(map.values());  
    }  
}
```

## 知识点
`computeIfAbsent(key, 生成函数)`
含义：根据 `key` 去 `map` 里找，找到了就直接返回对应的`value`；找不到就用你提供的函数创建一个新 `value`，自动放进`map`，然后返回它。
```java
// 伪代码逻辑
  V computeIfAbsent(K key, Function<K, V> mappingFunction) {
      if (map 里有这个 key) {
          return map.get(key);  // 直接返回，函数根本不执行
      } else {
          V newValue = mappingFunction.apply(key);  // 现在才创建
          map.put(key, newValue);                   // 自动放进去
          return newValue;
      }
  }
```
`k -> new ArrayList<>()` 是一个 `Lambda` 表达式。只有当 `key` **不**存在时，才会执行这个 `Lambda` 创建新对象。如果 `key` 已经存在，它直接返回旧值，不会创建多余的空 `List` 对象，节省内存开销。
关键点：只在 `key` 不存在时才执行创建函数，且自动 `put`。

| 对比项        | getOrDefault  | computeIfAbsent |
| ---------- | ------------- | --------------- |
| key 存在时    | 返回已有 value    | 返回已有 value      |
| key 不存在时   | 返回默认值，不放入 map | 创建新值，自动放入 map   |
| 默认值何时创建    | 每次都创建（浪费）     | 仅需要时才创建（懒加载     |
| 是否需要手动 put | 是             | 否               |

## 复杂度

- Time: O(n · k log k)
- Space: O(n · k)
 n 为字符串数量，k 为字符串最大长度；每个字符串排序 O(k log k)
## 相似题目

- [[ ]]

