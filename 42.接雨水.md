---
type: algorithm
tags: 双指针、单调栈
category: 动态规划
difficulty: 🔴 Hard
leetcode: 42
created: 2026-01-27 19:54
---

## 题目
![[42.png]]


## 思路（必填）

1. 动态规划，先从左边到右遍历，记录最大高度
2. 再从右到左遍历，记录最大高度。
3. 取两者最小值
4. 减去柱子的高度
5. 累加得到总雨水量

## 代码

```java
public static int trap(int[] height) {  
    if (height == null || height.length == 0) return 0;  
  
    int n = height.length;  
    int[] leftMax = new int[n];  
    int[] rightMax = new int[n];  
  
    leftMax[0] = height[0];  
    for (int i = 1; i < n; i++) {  
        leftMax[i] = Math.max(leftMax[i - 1], height[i]);  
    }  
    rightMax[n - 1] = height[n - 1];  
    for (int i = n - 2; i >= 0; i--) {  
        rightMax[i] = Math.max(rightMax[i + 1], height[i]);  
    }  
  
    int sum = 0;  
    for (int i = 0; i < n; i++) {  
        sum += Math.min(leftMax[i], rightMax[i]) - height[i];  
    }  
    return sum;  
}
```

## 答案代码
> [!TIP]   
双指针优化
在暴力解法中，我们可以看到只要记录左边柱子的最高高度 和 右边柱子的最高高度，就可以计算当前位置的雨水面积，这就是通过列来计算。
当前列雨水面积：min(左边柱子的最高高度，记录右边柱子的最高高度) - 当前柱子高度。
为了得到两边的最高高度，使用了双指针来遍历，每到一个柱子都向两边遍历一遍，这其实是有重复计算的。我们把每一个位置的左边最高高度记录在一个数组上（maxLeft），右边最高高度记录在一个数组上（maxRight），这样就避免了重复计算。
当前位置，左边的最高高度是前一个位置的左边最高高度和本高度的最大值。
即从左向右遍历：maxLeft[i] = max(height[i], maxLeft[i - 1]);
从右向左遍历：maxRight[i] = max(height[i], maxRight[i + 1]);


```java
双指针法（O(1) 空间，进阶优化）
class Solution {  
    public int trap(int[] height) {  
        int n = height.length;  
        int ans = 0;  
        int left = 0, right = n - 1;  
        int left_max = 0, right_max = 0;  
        while (left < right) {  
            left_max = Math.max(left_max, height[left]);  
            right_max = Math.max(right_max, height[right]);  
            if (height[left] < height[right]) {  
                ans += left_max - height[left];  
                left++;  
            } else {  
                ans += right_max - height[right];  
                right--;  
            }  
        }  
        return ans;  
    }  
}
```

## 知识点

1. 单调栈就是保持栈内元素有序。通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。而接雨水这道题目，我们正需要寻找一个元素，右边最大元素以及左边最大元素，来计算雨水面积。
2. 遇到相同的元素，更新栈内下标，就是将栈里元素（旧下标）弹出，将新元素（新下标）加入栈中。例如 5 5 1 3 这种情况。如果添加第二个5的时候就应该将第一个5的下标弹出，把第二个5添加到栈中。
3. 如果前缀最大值比后缀最大值小，那么左边木桶的容量就是前缀最大值；
4. 如果后缀最大值比前缀最大值小，那么右边木桶的容量就是后缀最大值；

## 复杂度

- Time: O(n)
- Space: O(n)

---

## 相似题目

- [[11.盛最多水的容器]]

