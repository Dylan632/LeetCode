---
type: algorithm
tags:
category: 链表
difficulty: 🟡 Medium
leetcode: 2
created: 2026-02-05 17:04
obsidian-note-status:
  - colorful:completed
---

## 题目
![[2.png]]

## 思路（必填）

1. 创建一个哨兵节点 `dummy` 作为结果链表的头，方便操作。
2. 使用 `carry` 变量记录进位。
3. 同时遍历两个链表，只要有一个链表未结束或还有进位，就继续循环。
4. 每次循环计算 `sum = val1 + val2 + carry`。
5. 更新进位 `carry = sum / 10`。
6. 创建新节点存储 `sum % 10`，接到结果链表后面。
7. 移动指针。

## 关键点
- 哨兵节点：简化头节点处理。
- 循环条件：`l1 != null || l2 != null || carry != 0` 是最优雅的写法，涵盖了所有边界情况。

## 代码

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode cur = dummy;
        int carry = 0; // carry 永远只可能是 0 或 1
        while (l1 != null || l2 != null || carry != 0) {
            int val1 = l1 != null ? l1.val : 0;
            int val2 = l2 != null ? l2.val : 0;
            int sum = val1 + val2 + carry;
            carry = sum / 10;
            cur.next = new ListNode(sum % 10);
            cur = cur.next;
            if (l1 != null) {
                l1 = l1.next;
            }
            if (l2 != null) {
                l2 = l2.next;
            }
        }
        return dummy.next;
    }
}
```

## 知识点
1. 问题分析：题目要求模拟两个非负整数的相加过程，整数以链表形式逆序存储（个位在表头）。
2. 模拟法：就像在纸上做加法一样，从个位开始相加，处理进位。
3. 数据结构：由于是逆序存储，直接从链表头开始遍历正好对应从低位到高位，非常方便。

## 复杂度

- Time: O()
- Space: O()

---

## 相似题目

- [[ ]]

