---
type: algorithm
tags: 双指针
category: 链表
difficulty: 🟢 Easy
leetcode: 160
created: "2026-02-05 16:23"
---

## 题目
![[160.png]]

## 思路（必填）

1. 
2. 
3. 

## 关键点
>[!TIP] 求两个链表交点节点的<font color="#ff0000">指针</font>要注意，<font color="#ffc000">交点不是数值相等（val相等），而是指针相等（内存地址相等）</font>。

## 代码

```java
public class Solution {  
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {  
        ListNode curA = headA;  
        ListNode curB = headB;  
        while (curA != curB) {  
	        //curA走一步，如果走到 A 链表末尾，则转到 B 链表；
            curA = (curA == null) ? headB : curA.next;  
            //curB走一步，如果走到 B 链表末尾，则转到 A 链表；
            curB = (curB == null) ? headA : curB.next;  
        }  
        return curA;  
    }  
}
```

## 答案代码
> [!TIP]  

```java

```

## 知识点
求两个链表交点节点的<font color="#ff0000">指针</font>要注意，<font color="#ffc000">交点不是数值相等（val相等），而是指针相等（内存地址相等）</font>。
举个通俗的例子：
- **数值相等**：你有一台 iPhone 15，我也有一台 iPhone 15。虽然它们看起来一模一样（数值相等），但这是两台不同的手机。
- **指针相等**：咱俩是室友，桌子上放着一台 iPhone 15。你指着它说“这是我的手机”，我指着它说“这也是我的手机”。这时候，我们指的是**同一台实物**。这就是链表的“相交”。
![[160_3.png]]
如图所示，两个1的数值相等，但指针不相等。

第一次用了 `curA.next == null`，错误❌
- 如果两个链表完全不相交，标准的算法要求两个指针最后同时变成`null`，从而跳出`while (curA != curB)`循环（因为`null == null`）。
- 但是你的写法是检查`curA.next == null`就立刻跳到`headB`。这意味着`curA`**永远不可能变成 null**。
- 如果两个链表不相交，`curA`和`curB`就永远在两个链表之间反复横跳，永远不会相等，导致死循环。

这题难点在于由于两条链表的长度可能不同，两条链表之间的节点无法对应：
![[160_1.png]]
如果用两个指针`p1`和`p2`分别在两条链表上前进，并不能**同时**走到公共节点，也就无法得到相交节点`c1`。
**解决这个问题的关键是，通过某些方式，让`p1`和`p2`能够同时到达相交节点`c1`**。
如果用两个指针`p1`和`p2`分别在两条链表上前进，我们可以让`p1`遍历完链表`A`之后开始遍历链表`B`，让`p2`遍历完链表`B`之后开始遍历链表`A`，这样相当于「逻辑上」两条链表接在了一起。如果这样进行拼接，就可以让`p1`和`p2`同时进入公共部分，也就是同时到达相交节点`c1`：
![[160_2.png]]

## 复杂度

- Time: O()
- Space: O()

---

## 相似题目

- [[ ]]

