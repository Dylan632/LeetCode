---
type: algorithm
tags: 二分查找
category: 数组
difficulty: 🟢 Easy
leetcode: 35
created: 2026-02-05 10:44
obsidian-note-status:
  - colorful:completed
---

## 题目

![[35.png]]
## 思路（必填）

1. 设定左右边界 `left/right`
2. 取中点 `mid` 与 `target` 比较
3. 缩小区间，直到区间为空
4. 返回插入位置  

## 关键点
循环结束时 `left` 即为插入位置。

示例2： 输入[1,3,5,6],2
把二分查找想象成在找一条**分界线**。 循环结束时，`left` 和 `right` 错开了，它们中间的那条缝，就是你要插入的地方。
![[35二分插入.png]]
- **`right`** 在左边守门（所有比 `target` 小的都在 `right` 及其左边）。
- **`left`** 在右边守门（所有比 `target` 大的都在 `left` 及其右边）。

数学上，当二分查找的 `while (left <= right)` 循环结束时，一定满足：`left = right + 1`

## 代码

```java
class Solution {  
    public int searchInsert(int[] nums, int target) {  
        int left = 0, right = nums.length - 1;  
        while (left <= right) {  
            int mid = left + (right - left) / 2;  
            if (nums[mid] == target) {  
	            // 1. 目标值等于数组中某一个元素  return mid;               
	            return mid;  
            } else if (nums[mid] > target) {  
                right = mid - 1;  
            } else {  
                left = mid + 1;  
            }  
        }  
        // 2.目标值在数组所有元素之前  
        //3.目标值插入数组中  
        //4.目标值在数组所有元素之后 return right + 1;        
        return left; //等价于 right + 1    
    }  
}
```

## 知识点


## 复杂度

- Time: O(logn)
- Space: O(1)

---

## 相似题目

- [[704. 二分查找法]]

