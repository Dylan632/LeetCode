---
type: algorithm
tags:
category:
difficulty:
leetcode:
created: 2026-02-11 15:27
obsidian-note-status:
  - colorful:needsUpdate
---

## 题目
![[94.png]]

## 思路（必填）

1. 
2. 
3. 

## 详细讲解

### 代码分两个方法

**inorderTraversal — 入口方法**
- 创建一个空列表 result
- 把 result 传给递归方法 inorder，让它在遍历过程中把节点值填进去
- 遍历结束后返回 result

**inorder — 递归方法，接收两个参数：**
- node：当前要处理的节点
- result：结果列表的引用（所有递归层共享同一个列表）

### 为什么 result 要作为参数传递

result 在 inorderTraversal 里创建，然后传给 inorder。每一层递归调用都拿到的是同一个列表对象的引用，所以无论递归到哪一层，`result.add()` 都是往同一个列表里加元素。

这比把 result 放成成员变量更好——每次调用 inorderTraversal 都会创建新的列表，不会有上一次调用的残留数据。

### 递归执行过程

用这棵树举例：

```
    1
     \
      2
     /
    3
```

**第一步：调用 inorder(节点1, result)**

节点1不是 null，执行三行核心代码：

1. `inorder(节点1.left, result)` → `inorder(null, result)`
   null，直接 return。左子树处理完毕。

2. `result.add(1)`
   result = [1]

3. `inorder(节点1.right, result)` → `inorder(节点2, result)`
   进入节点2的处理……

**第二步：处理节点2**

4. `inorder(节点2.left, result)` → `inorder(节点3, result)`
   进入节点3的处理……

**第三步：处理节点3**

5. `inorder(节点3.left, result)` → `inorder(null, result)`
   null，return。

6. `result.add(3)`
   result = [1, 3]

7. `inorder(节点3.right, result)` → `inorder(null, result)`
   null，return。

节点3处理完毕，返回到节点2，继续执行节点2剩下的代码：

**回到节点2**

8. `result.add(2)`
   result = [1, 3, 2]

9. `inorder(节点2.right, result)` → `inorder(null, result)`
   null，return。

节点2处理完毕，返回到节点1，节点1的三行也都执行完了。

**最终结果：[1, 3, 2]**

### 递归执行过程（完整模拟）

用这棵树举例：

```
    1
     \
      2
     /
    3
```

```
inorder(1, result)                          result = []
├── inorder(1.left=null, result)
│   └── null，return                        什么都不做
├── result.add(1)                           result = [1]
└── inorder(1.right=2, result)
    ├── inorder(2.left=3, result)
    │   ├── inorder(3.left=null, result)
    │   │   └── null，return
    │   ├── result.add(3)                   result = [1, 3]
    │   └── inorder(3.right=null, result)
    │       └── null，return
    ├── result.add(2)                       result = [1, 3, 2]
    └── inorder(2.right=null, result)
        └── null，return
```

**最终结果：[1, 3, 2]**

---

### 再用一棵更完整的树模拟

```
      1
     / \
    2   3
   / \
  4   5
```

```
inorder(1, result)                              result = []
├── inorder(1.left=2, result)
│   ├── inorder(2.left=4, result)
│   │   ├── inorder(4.left=null, result)
│   │   │   └── null，return
│   │   ├── result.add(4)                       result = [4]
│   │   └── inorder(4.right=null, result)
│   │       └── null，return
│   ├── result.add(2)                           result = [4, 2]
│   └── inorder(2.right=5, result)
│       ├── inorder(5.left=null, result)
│       │   └── null，return
│       ├── result.add(5)                       result = [4, 2, 5]
│       └── inorder(5.right=null, result)
│           └── null，return
├── result.add(1)                               result = [4, 2, 5, 1]
└── inorder(1.right=3, result)
    ├── inorder(3.left=null, result)
    │   └── null，return
    ├── result.add(3)                           result = [4, 2, 5, 1, 3]
    └── inorder(3.right=null, result)
        └── null，return
```

**最终结果：[4, 2, 5, 1, 3]**

可以验证这就是中序（左→中→右）的正确结果：
- 节点2的左子树 4 → 节点 2 → 节点2的右子树 5
- 节点1的左子树 [4,2,5] → 节点 1 → 节点1的右子树 3

每个节点都严格遵循「先把左边全部处理完，再加自己，再处理右边」。

---


## 关键点
>[!Tip]

## 代码

```java
class Solution {  
    //一维列表  
    public List<Integer> resList = new ArrayList<Integer>();  
    public List<Integer> inorderTraversal(TreeNode root) {  
        checkFun(root);  
        return resList;  
    }  
    public void checkFun(TreeNode node) {  
        if (node == null) {  
            return;  
        }  
        checkFun(node.left);  
        //中序遍历，add在中间
        resList.add(node.val);  
        checkFun(node.right);  
    }  
}
```

## 知识点


## 复杂度

- Time: O()
- Space: O()

---

## 相似题目

- [[ ]]

